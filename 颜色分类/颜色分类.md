## 题目：

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sort-colors
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

<!--more-->

## 思路：

- 需要两个指针，一个用来记录0，一个记录2，还有一个遍历0和2之间的数值， 需要注意是2换去后来 换来的数值不一定是0可以跳过的 所以curr此时不能+1，具体思路：
  - 定义两个指针，一个指向开头，一个指向结尾
  - 遍历数组
  - 如果遇到0，则让该位置的数与开头的指针交换，之后指针++；
  - 如果遇到2，则与后面的指针交换，指针--，此时最后的位置已经为2，在遍历的时候就不能在遍历的，如果遍历到那个数，就会产生交换。
  - 但是此时只知道最后一个数是2，但不知道交换过来的数是否是0，所以，不能再进行下一次遍历，还要继续判断这个新传来的数

## 代码：

```java
public void sortColors(int[] nums) {
        int n=nums.length;
        int left=0;
        int end=nums.length-1;
        for (int i=0;i<n;i++){
            if (nums[i]==0){
//                与前指针交换
//                left++，先执行后++
                exchange(nums,i,left++);
            }
            if (nums[i]==2){
//                同样遇到2，与后面指针对应的数交换位置
                exchange(nums,i,end--);
//                不必遍历新换的数了
                n--;
//                判断新换来的数
                i-=1;
            }
        }
    }
//    两个数字交换的方法
    private void exchange(int[] nums,int i,int temp){
        int backups=nums[temp];
        nums[temp]=nums[i];
        nums[i]=backups;
    }
```

## 结果：

![image-20220128172711930](https://gitee.com/misteryliu/typora/raw/master/image/image-20220128172711930.png)